% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/indexCDI.R
\name{CDI}
\alias{CDI}
\title{Condition Duration Index}
\usage{
CDI(
  df,
  id = "id",
  start_date,
  season_start = "07-01",
  season_end = "06-30",
  bounds,
  combiner = c("all", "any", "k_of_n")[1],
  k = NULL,
  min_duration = 1,
  na_action = c("false", "skip_vars", "skip_days")[1]
)
}
\arguments{
\item{df}{Tibble/data.frame with one row per day and per \code{id}. Must have
the same number of rows for each \code{id}. Variables referenced in \code{bounds}
must be numeric columns in \code{df}.}

\item{id}{Character, name of the id column (default \code{"id"}).}

\item{start_date}{Date of the first row for each \code{id} (daily-regular series).}

\item{season_start, season_end}{Character \code{"mm-dd"}, defining the start and
end of the season window. The window may cross calendar years (e.g.
\code{"07-01"} to \code{"06-30"}).}

\item{bounds}{Tibble or data frame defining \strong{per-variable thresholds}.
It must contain one row per variable with at least the column:
\describe{
\item{\code{var}}{Character: name of the variable in \code{df} to evaluate.}
}
Optional columns allow specifying the interval and inclusivity criteria
for each variable:
\describe{
\item{\code{lower}}{Numeric lower bound (default \code{-Inf}).}
\item{\code{upper}}{Numeric upper bound (default \code{Inf}).}
\item{\code{inc_lower}}{Logical; whether the lower bound is inclusive (default \code{TRUE}).}
\item{\code{inc_upper}}{Logical; whether the upper bound is inclusive (default \code{TRUE}).}
}
For example:\preformatted{bounds <- tibble::tibble(
  var = c("temp","humidity"),
  lower = c(10, 40),
  upper = c(30, 80),
  inc_lower = TRUE,
  inc_upper = TRUE
)
}

A day is considered valid for a given variable if its value lies within
the specified range (taking inclusivity into account).}

\item{combiner}{Character specifying how to \strong{combine} per-variable conditions
into a single daily condition (\code{cond}):
\describe{
\item{\code{"all"}}{All variables must meet their condition for the day to be
considered valid. Equivalent to a logical AND.}
\item{\code{"any"}}{At least one variable meets its condition. Equivalent to
a logical OR.}
\item{\code{"k_of_n"}}{At least \code{k} of the \code{n} variables meet their condition.
Useful for indices that require simultaneous satisfaction of several,
but not necessarily all, criteria (e.g., "at least 2 of 3 stressors
below threshold"). Requires argument \code{k}.}
}}

\item{k}{Integer ≥ 1, required only when \code{combiner = "k_of_n"}. It defines
the minimum number of variables that must pass their individual conditions
for a day to be marked as valid (\code{cond = TRUE}). For example, with
three variables and \code{k = 2}, a day is valid if at least two of them are
within their specified ranges.}

\item{min_duration}{Integer ≥ 1. Minimum number of \strong{consecutive days}
that must satisfy the combined daily condition (\code{cond = TRUE}) before
the run starts contributing to the cumulative count.
\itemize{
\item If \code{min_duration = 1}, every valid day contributes immediately.
\item If \code{min_duration = 5}, only when a run of 5 consecutive valid days is
reached do those days begin to count, and the function automatically
adds the previous 4 days at that point (bias correction).
}}

\item{na_action}{Character, controlling how \strong{missing values} (\code{NA}) are
handled. Options:
\describe{
\item{\code{"false"}}{Treats \code{NA} as \emph{not satisfying} the condition.
Missing values break runs and are equivalent to days that fail the
thresholds.}
\item{\code{"skip_vars"}}{When combining across variables, ignore \code{NA}
for that variable only. For \code{"all"} or \code{"k_of_n"}, this means a day
can still be valid if enough other variables are available and meet
their conditions.}
\item{\code{"skip_days"}}{Drops entire days that contain at least one \code{NA}
among the variables referenced in \code{bounds}, before evaluating
conditions. Consecutivity is preserved only across remaining (non-NA)
days.}
}}
}
\value{
Tibble with daily rows and columns:
\itemize{
\item \code{id} — station or spatial cell identifier.
\item \code{day_idx} — daily index within the full time series.
\item \code{season_id}, \code{season_label} — season grouping identifiers.
\item \code{cond} — logical vector of days meeting the combined condition.
\item \code{valid} — logical vector indicating if the day is part of a run
that reached the required \code{min_duration}.
\item \code{cum_days} — cumulative number of valid days since season start,
corrected for incomplete runs.
}
}
\description{
Daily accumulator for multi-variable day counts.
For each \code{id} and season, compute a \emph{daily} cumulative counter \code{cum_days}
of days that satisfy a combined condition across multiple variables, with
a minimum-run constraint \code{min_duration}. The function supports flexible
logic to combine conditions across variables and to control how missing
values are treated. It uses an \strong{online} algorithm with \strong{per-run bias
correction}, ensuring that cumulative values match retrospective counts
for completed runs, while remaining conservative for ongoing (incomplete)
runs.
}
\details{
The algorithm proceeds day by day ("online"), tracking consecutive valid
runs and applying a \strong{per-run correction} once a run first reaches
\code{min_duration}. This ensures that the cumulative counts per season match
what would be obtained with a complete retrospective analysis, while
remaining unbiased for incomplete ongoing runs (e.g., when the current
season is still in progress).
}
\examples{
bounds <- tibble::tibble(
  var = c("temp", "humidity"),
  lower = c(10, 40),
  upper = c(30, 80)
)

# Count days where both variables meet their conditions
CDI(df,
  id = "id", start_date = min(df$date),
  bounds = bounds, combiner = "all", min_duration = 3
)

# Require at least 2 of 3 variables to meet their conditions
CDI(df,
  id = "id", start_date = min(df$date),
  bounds = bounds, combiner = "k_of_n", k = 2
)

}
\author{
Sara Herrera
}
